<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CX Flavor Tool (Restart)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 16px; background:#fafafa; color:#111; }
    h1 { margin: 0 0 12px; font-size: 20px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .card { background:#fff; border:1px solid #e6e6e6; border-radius:12px; padding:12px; box-shadow:0 1px 4px rgba(0,0,0,.04); }
    .card h2 { margin:0 0 8px; font-size:16px; }
    .grow { flex: 1 1 420px; }
    textarea, input[type="text"], select {
      width:100%; box-sizing:border-box; padding:10px;
      border-radius:10px; border:1px solid #ddd; background:#fff;
    }
    textarea { min-height: 160px; resize: vertical; }
    button { padding:10px 12px; border-radius:10px; border:1px solid #ddd; background:#111; color:#fff; cursor:pointer; }
    button.secondary { background:#fff; color:#111; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .muted { color:#666; font-size: 12px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f1f1; border:1px solid #e6e6e6; font-size:12px; }
    .grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    table { width:100%; border-collapse: collapse; }
    th, td { padding:8px; border-bottom:1px solid #eee; vertical-align: top; }
    th { text-align:left; font-size:12px; color:#333; cursor:pointer; user-select:none; }
    tr:hover td { background:#fcfcfc; }
    .right { text-align:right; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size:12px; }
    .statusActive { color:#0a7; font-weight:600; }
    .statusInactive { color:#a44; font-weight:600; }
    .split { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .split > * { flex: 1 1 220px; }
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .toolbar > * { flex: 0 0 auto; }
    .toolbar .grow { flex: 1 1 260px; }
  </style>
</head>
<body>
  <h1>CX Flavor Tool (Order Mapper • Nutrition • Ingredients)</h1>

  <!-- Minimal status strip -->
  <div class="card">
    <div class="split">
      <div>
        <div><strong>Data</strong></div>
        <div class="muted" id="loadStatus">Starting…</div>
      </div>
      <div class="right">
        <button id="refreshData" class="secondary">Refresh</button>
      </div>
    </div>
    <div class="muted" id="debugStatus" style="margin-top:6px;"></div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="card grow">
      <h2>Order Mapper</h2>
      <div class="muted">
        Paste customer list OR warehouse list like:
        <span class="mono">3 × (1-1-1) Pumpkin</span>. Output: <span class="mono"># x Flavor</span>.
      </div>
      <textarea id="orderInput" placeholder="3 × (1-1-1) Pumpkin
2 × (5-1-4) CHERRYPIE
Cherry Pie
x 2"></textarea>
      <div style="margin-top:10px;" class="split">
        <button id="mapOrder" disabled>Map Order</button>
        <div class="muted">Matches only <span class="pill">Active</span> flavors by default.</div>
      </div>
      <textarea id="orderOutput" class="mono" placeholder="Output appears here…" style="margin-top:10px; min-height:140px;"></textarea>
      <div class="muted" id="orderNotes" style="margin-top:8px;"></div>
    </div>

    <div class="card grow">
      <h2>Nutritional Label Lookup</h2>
      <div class="muted">Type a flavor name (fuzzy) → nutrition + ingredients.</div>
      <input id="labelFlavor" type="text" placeholder="e.g., Glazed Blueberry Donut" />
      <div style="margin-top:10px;">
        <button id="lookupLabel" disabled>Lookup</button>
      </div>
      <div id="labelResult" style="margin-top:10px;" class="small"></div>
    </div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="card grow">
      <h2>Ingredient Lookup</h2>
      <div class="muted">Search flavors with an ingredient OR list flavors without an ingredient. (Shakers/scoops excluded.)</div>
      <input id="ingredientQuery" type="text" placeholder="e.g., raspberry, strawberries, cocoa, cinnamon" />

      <div style="margin-top:10px;" class="split">
        <div class="split" style="flex:2;">
          <button id="searchIngredient" disabled>Search ingredient</button>
          <button id="listWithoutIngredient" class="secondary" disabled>Flavors without ingredient</button>
          <label class="muted"><input id="includeInactiveIng" type="checkbox" /> include inactive</label>
        </div>
        <div class="right" style="flex:1;">
          <button id="copyIngredientResults" class="secondary" disabled>Copy results</button>
        </div>
      </div>

      <div id="ingredientResult" style="margin-top:10px;" class="small"></div>

      <!-- hidden copy buffer -->
      <textarea
        id="ingredientCopyBuffer"
        class="mono"
        style="position:absolute; left:-9999px; top:-9999px;"
      ></textarea>
    </div>

    <div class="card grow">
      <h2>Nutrition Tracker</h2>
      <div class="muted">Pick a macro/nutrient → top/bottom 10. Filter Oats/Coffee + Vegan. Shakers & scoops excluded.</div>

      <div class="split" style="margin-top:8px;">
        <div>
          <div class="muted">Macro / nutrient</div>
          <select id="macroSelect" disabled></select>
        </div>

        <div>
          <div class="muted">Product filter</div>
          <select id="productFilter" disabled>
            <option value="all">All</option>
            <option value="oats">Only Oats</option>
            <option value="coffee">Only Coffee</option>
          </select>
          <div class="muted" style="margin-top:6px;">Shakers & scoops excluded.</div>
        </div>

        <div>
          <div class="muted">Vegan filter</div>
          <select id="veganFilter" disabled>
            <option value="all">All</option>
            <option value="vegan">Only Vegan</option>
            <option value="nonvegan">Only Non-Vegan</option>
            <option value="unknown">Unknown</option>
          </select>
        </div>

        <div class="right">
          <button id="calcExtremes" disabled>Compute Most/Least</button>
          <div style="margin-top:8px;">
            <label class="muted"><input id="includeInactiveNut" type="checkbox" /> include inactive</label>
          </div>
        </div>
      </div>

      <div id="extremes" style="margin-top:10px;" class="small"></div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <div class="split">
      <h2 style="margin:0;">All Flavors (sortable)</h2>
      <div class="right">
        <input id="tableSearch" type="text" placeholder="Search table…" />
      </div>
    </div>

    <div class="toolbar" style="margin-top:10px;">
      <div class="muted">Filters:</div>
      <select id="tableProductFilter" disabled>
        <option value="all">All products</option>
        <option value="oats">Oats only</option>
        <option value="coffee">Coffee only</option>
        <option value="exclude_oats">Exclude oats</option>
        <option value="exclude_coffee">Exclude coffee</option>
      </select>

      <select id="tableVeganFilter" disabled>
        <option value="all">All</option>
        <option value="vegan">Vegan</option>
        <option value="nonvegan">Non-Vegan</option>
        <option value="unknown">Unknown</option>
      </select>

      <label class="muted"><input id="tableIncludeInactive" type="checkbox" /> include inactive</label>
    </div>

    <div class="muted" style="margin-top:6px;">Click a header to sort. Table shows only items with nutrition values.</div>
    <div style="overflow:auto; margin-top:10px;">
      <table id="flavorTable"></table>
    </div>
  </div>

  <script>
    // ==============================
    // Google Sheets (Apps Script) API
    // ==============================
    // IMPORTANT: this should be the one that works when opened directly in your browser.
    const SHEET_API_URL =
      "https://script.google.com/macros/s/AKfycbyAMUDmfbvy2LxjQhJ-RJMJak0QCQ6eITXPSkP4-rnHa1dlInXbMtdvcRdSqFnXHu8Z/exec";

    // Auto-refresh interval (minutes)
    const AUTO_REFRESH_MINUTES = 10;

    /**********************
     * Small utilities
     **********************/
    const norm = (s) => (s ?? "").toString().trim().toLowerCase()
      .replace(/\s+/g, " ")
      .replace(/[’']/g, "")
      .replace(/&/g, " and ")
      .replace(/[^a-z0-9 ]/g, " ")
      .replace(/\s+/g, " ")
      .trim();

    const collapse = (s) => norm(s).replace(/\s+/g, "");

    function escapeHtml(s) {
      return (s ?? "").toString()
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function toNumber(x) {
      const s = (x ?? "").toString().trim();
      if (s === "") return null; // blanks -> null
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    }

    function fmtUpdatedAt(iso) {
      if (!iso) return "";
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return iso;
      return d.toLocaleString(undefined, {
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit"
      });
    }

    function setDebugStatus(msg) {
      document.getElementById("debugStatus").textContent = msg || "";
    }

    // --- Simple stemming for better plural matching (ingredients) ---
    function singularize(word) {
      let w = (word || "").toLowerCase();
      if (w.endsWith("ies") && w.length > 3) return w.slice(0, -3) + "y";
      if (w.endsWith("es") && w.length > 3) return w.slice(0, -2);
      if (w.endsWith("s") && w.length > 3 && !w.endsWith("ss")) return w.slice(0, -1);
      return w;
    }

    function pluralize(word) {
      let w = (word || "").toLowerCase();
      if (!w) return w;
      if (w.endsWith("y") && w.length > 2) return w.slice(0, -1) + "ies";
      return w + "s";
    }

    function stemToken(word) {
      let w = singularize(word);
      if (w.endsWith("ed") && w.length > 4) w = w.slice(0, -2);
      if (w.endsWith("ing") && w.length > 5) w = w.slice(0, -3);
      return w;
    }

    function tokenSetStemmed(s) {
      const cleaned = norm(s);
      const tokens = cleaned.split(" ").filter(Boolean).map(stemToken);
      return new Set(tokens.filter(Boolean));
    }

    function stemmedString(s) {
      return [...tokenSetStemmed(s)].join(" ");
    }

    function queryTokenVariants(token) {
      const t = norm(token);
      if (!t) return [];
      const s = singularize(t);
      const p = pluralize(s);
      return [...new Set([t, s, p])].filter(Boolean);
    }

    function queryVariantsString(query) {
      const tokens = norm(query).split(" ").filter(Boolean);
      const variants = new Set();
      for (const tok of tokens) {
        for (const v of queryTokenVariants(tok)) variants.add(v);
      }
      return [...variants];
    }

    // Very small fuzzy score (0..1)
    function fuzzyScore(a, b) {
      a = norm(a); b = norm(b);
      if (!a || !b) return 0;
      if (a === b) return 1;
      if (a.includes(b) || b.includes(a)) return 0.92;

      const at = new Set(a.split(" ").filter(Boolean));
      const bt = new Set(b.split(" ").filter(Boolean));
      const inter = [...at].filter(x => bt.has(x)).length;
      const union = new Set([...at, ...bt]).size || 1;
      const jacc = inter / union;

      const ac = new Set([...a]); const bc = new Set([...b]);
      const cInter = [...ac].filter(x => bc.has(x)).length;
      const cUnion = new Set([...ac, ...bc]).size || 1;
      const cJacc = cInter / cUnion;

      return Math.max(jacc * 0.75 + cJacc * 0.25, 0);
    }

    // Ingredient-specific score
    function ingredientScore(query, ingredientCell) {
      const qNorm = norm(query);
      const iNorm = norm(ingredientCell);
      if (!qNorm || !iNorm) return 0;

      const qVars = queryVariantsString(query);
      for (const v of qVars) {
        if (v && iNorm.includes(v)) return 0.96;
      }

      const qStem = stemmedString(qNorm);
      const iStem = stemmedString(iNorm);
      if (qStem && iStem && iStem.includes(qStem)) return 0.93;

      const qt = tokenSetStemmed(qNorm);
      const it = tokenSetStemmed(iNorm);
      const inter = [...qt].filter(x => it.has(x)).length;
      const union = new Set([...qt, ...it]).size || 1;
      const jacc = inter / union;

      const base = fuzzyScore(qNorm, iNorm);
      return Math.max(0, jacc * 0.75 + base * 0.25);
    }

    function bestFuzzyMatch(query, candidates) {
      let best = null;
      for (const c of candidates) {
        const sc = fuzzyScore(query, c);
        if (!best || sc > best.score) best = { value: c, score: sc };
      }
      return best;
    }

    function bestFuzzyMatchObj(query, objects, getField) {
      let best = null;
      for (const obj of objects) {
        const val = (getField(obj) ?? "").toString();
        if (!val.trim()) continue;
        const sc = fuzzyScore(query, val);
        if (!best || sc > best.score) best = { obj, value: val, score: sc };
      }
      return best;
    }

    /**********************
     * Copy helpers (Ingredient results)
     **********************/
    function setIngredientCopyBuffer(lines) {
      const buf = document.getElementById("ingredientCopyBuffer");
      const btn = document.getElementById("copyIngredientResults");

      if (!lines || !lines.length) {
        buf.value = "";
        btn.disabled = true;
        btn.textContent = "Copy results";
        return;
      }

      buf.value = lines.join("\n");
      btn.disabled = false;
      btn.textContent = "Copy results";
    }

    function copyIngredientResults() {
      const buf = document.getElementById("ingredientCopyBuffer");
      if (!buf.value) return;

      buf.select();
      buf.setSelectionRange(0, buf.value.length);
      document.execCommand("copy");

      const btn = document.getElementById("copyIngredientResults");
      btn.textContent = "Copied!";
      setTimeout(() => (btn.textContent = "Copy results"), 1200);
    }

    /**********************
     * Warehouse-line parsing
     **********************/
    function parseWarehouseLine(line) {
      const m = line.match(/^\s*(\d+)\s*[x×]\s*\(([^)]+)\)\s*(.+?)\s*$/i);
      if (!m) return null;
      return { qty: Number(m[1]), code: m[2].trim(), name: m[3].trim(), raw: line };
    }

    function cleanWarehouseItemName(name) {
      let s = (name ?? "").toString();
      s = s.replace(/\([^)]*\)/g, " ");       // remove tags like (OATMEAL FID)
      s = s.replace(/\b(fid|oatmeal)\b/gi, " ");
      s = s.replace(/\b(sample|sampler|samp)\b/gi, " ");
      s = s.replace(/\s+/g, " ").trim();
      return s;
    }

    /**********************
     * Exclusions + Product filtering
     **********************/
    function isExcludedNonFlavor(f) {
      const name = norm(f.flavor_name);
      const product = norm(f.product);
      const code = norm(f.warehouse_code);
      const hay = `${name} ${product} ${code}`;

      const banned = [
        "shaker", "bottle", "scoop", "scoops",
        "blenderbottle", "blender bottle",
        "starter kit", "sample scoop"
      ];
      return banned.some(b => hay.includes(norm(b)));
    }

    function productPassesFilter(f, filterValue) {
      const p = norm(f.product);
      if (filterValue === "oats") return p.includes("oat");
      if (filterValue === "coffee") return p.includes("coffee");
      if (filterValue === "exclude_oats") return !p.includes("oat");
      if (filterValue === "exclude_coffee") return !p.includes("coffee");
      return true;
    }

    function parseVeganValue(v) {
      const s = (v ?? "").toString().trim().toLowerCase();
      if (!s) return "unknown";
      if (["yes","y","true","1","vegan"].includes(s)) return "vegan";
      if (["no","n","false","0","non-vegan","nonvegan"].includes(s)) return "nonvegan";
      return "unknown";
    }

    function veganPassesFilter(f, filterValue) {
      if (!filterValue || filterValue === "all") return true;
      return (f.vegan || "unknown") === filterValue;
    }

    /**********************
     * Aliases (customer typed)
     **********************/
    const CUSTOMER_ALIASES = new Map([
      ["oreo", "cookies and cream"],
      ["choc chip", "chocolate chip cookie dough"],
      ["glzd bluberry", "glazed blueberry donut"],
      ["glzd blubry", "glazed blueberry donut"],
      ["choc cvrd banana", "chocolate covered banana"],
      ["b foster", "bananas foster"],
      ["ckie butter", "cookie butter"],
      ["choc satin pie", "chocolate satin pie"],
      ["smores", "smores"],
      ["strawberry", "strawberries and cream"],
      ["pumpkin", "pumpkin pie"],
      ["wht choc rspbry", "white chocolate raspberry"],
      ["pear crumble", "pear & apple crumble"],
      ["pina colada", "pina colada"],
      ["pb&j", "peanut butter & jelly"],
      ["orange", "orange cream pop"],
      ["spice latte", "pumpkin spice latte"],
      ["strwbry banana", "strawberry banana"],
      ["gingerbread", "gingerbread"],
      ["coconut", "coconut cream pie"],
      ["toffee", "salted toffee"],
      ["blueberry", "blueberry cobbler"],
      ["matcha", "matcha mango"],
      ["snicker", "snickerdoodle"],
      ["caramel apple", "caramel apple"]
      // IMPORTANT: intentionally NOT mapping ["apple", ...] because it breaks warehouse Apple mapping
    ]);

    function applyCustomerAlias(s) {
      const k = norm(s);
      return CUSTOMER_ALIASES.get(k) ?? s;
    }

    function isCookiesCoffeeIntent(rawLine) {
      const s = (rawLine ?? "").toString().toLowerCase();
      // Only treat as coffee if explicitly signaled
      return /\b(pc|protein\s*coffee|protien\s*coffee)\b/.test(s);
    }

    /**********************
     * Data model
     **********************/
    let rows = [];
    let flavors = [];
    let nutritionCols = [];
    let ingredientCols = [];
    let tableSort = { key: "flavor_name", dir: "asc" };

    // lookups
    let exactFlavorLookup = new Map();
    let collapsedFlavorLookup = new Map();
    let exactWarehouseLookup = new Map();
    let collapsedWarehouseLookup = new Map();

    // metadata
    let lastUpdatedAt = null;
    let lastSheetName = null;

    function setLoadStatus(msg) {
      document.getElementById("loadStatus").textContent = msg;
    }

    function setEnabled(on) {
      for (const id of ["mapOrder","lookupLabel","searchIngredient","listWithoutIngredient","calcExtremes"]) {
        document.getElementById(id).disabled = !on;
      }
      document.getElementById("refreshData").disabled = false;

      document.getElementById("tableProductFilter").disabled = !on;
      document.getElementById("tableVeganFilter").disabled = !on;
      document.getElementById("tableIncludeInactive").disabled = !on;

      document.getElementById("veganFilter").disabled = !on;
    }

    function resolveCanonicalFlavorName(targetName) {
      const n = norm(targetName);
      const c = collapse(targetName);
      return exactFlavorLookup.get(n) || collapsedFlavorLookup.get(c) || targetName;
    }

    function buildModel(parsedRows) {
      rows = parsedRows;

      const trimmed = rows.map(r => {
        const o = {};
        for (const k of Object.keys(r)) o[k.trim()] = r[k];
        return o;
      });

      const headerKeys = Object.keys(trimmed[0] || {});
      const pickKey = (candidates) => {
        for (const c of candidates) if (headerKeys.includes(c)) return c;
        const lower = new Map(headerKeys.map(k => [k.toLowerCase(), k]));
        for (const c of candidates) {
          const hit = lower.get(c.toLowerCase());
          if (hit) return hit;
        }
        return null;
      };

      const FLAVOR_KEY   = pickKey(["flavor_name", "Flavor", "flavor", "name", "Item Name", "item_name"]);
      const PRODUCT_KEY  = pickKey(["Product", "product"]);
      const STATUS_KEY   = pickKey(["Status", "status"]);
      const WH_CODE_KEY  = pickKey(["warehouse_code", "Warehouse Code", "warehouse code", "warehouse", "code"]);
      const VEGAN_KEY    = pickKey(["Vegan", "vegan", "is_vegan", "Is Vegan"]);

      ingredientCols = Object.keys(trimmed[0] || {}).filter(k => {
        const kk = k.toLowerCase();
        return kk.startsWith("ingredient_") || kk.startsWith("ingredient");
      });

      const candidateNutrition = [
        "serving_size_g","calories","protein_g","carbs_g","sugar_g","added_sugar_g","fiber_g",
        "fat_g","saturated_fat_g","sodium_mg","cholesterol_mg","caffeine_mg"
      ];
      nutritionCols = candidateNutrition.filter(c => c in (trimmed[0] || {}));

      // Populate dropdowns
      const macroSelect = document.getElementById("macroSelect");
      macroSelect.innerHTML = nutritionCols.map(c => `<option value="${c}">${c}</option>`).join("");
      macroSelect.disabled = false;
      if (nutritionCols.includes("calories")) macroSelect.value = "calories";

      document.getElementById("productFilter").disabled = false;
      document.getElementById("veganFilter").disabled = false;

      flavors = trimmed.map(r => {
        const flavorName = ((FLAVOR_KEY ? r[FLAVOR_KEY] : "") ?? "").toString().trim();
        const status = (((STATUS_KEY ? r[STATUS_KEY] : "") ?? r.Status ?? r.status) ?? "Active").toString().trim();

        const ingredients = ingredientCols
          .map(c => (r[c] ?? "").toString().trim())
          .filter(x => x && x.toLowerCase() !== "nan");

        const nutrition = {};
        for (const c of nutritionCols) nutrition[c] = toNumber(r[c]);

        const veganRaw = VEGAN_KEY ? r[VEGAN_KEY] : (r.Vegan ?? r.vegan ?? "");
        const vegan = parseVeganValue(veganRaw);

        return {
          id: (r.flavor_id_clean ?? r.flavor_id ?? flavorName ?? "").toString().trim(),
          flavor_name: flavorName,
          flavor_name_norm: norm(flavorName),
          status,
          product: ((PRODUCT_KEY ? r[PRODUCT_KEY] : "") ?? "").toString().trim(),
          warehouse_code: ((WH_CODE_KEY ? r[WH_CODE_KEY] : "") ?? "").toString().trim(),
          vegan,
          nutrition,
          ingredients,
          ingredients_norm: ingredients.map(norm)
        };
      });

      // Build exact lookup maps
      exactFlavorLookup = new Map();
      collapsedFlavorLookup = new Map();
      exactWarehouseLookup = new Map();
      collapsedWarehouseLookup = new Map();

      for (const f of flavors) {
        const fn1 = norm(f.flavor_name);
        const fn2 = collapse(f.flavor_name);
        if (fn1) exactFlavorLookup.set(fn1, f.flavor_name);
        if (fn2) collapsedFlavorLookup.set(fn2, f.flavor_name);

        const wh1 = norm(f.warehouse_code);
        const wh2 = collapse(f.warehouse_code);
        if (wh1) exactWarehouseLookup.set(wh1, f.flavor_name);
        if (wh2) collapsedWarehouseLookup.set(wh2, f.flavor_name);
      }

      renderTable();
      setEnabled(true);

      const meta =
        `Loaded ${flavors.length} rows` +
        (lastSheetName ? ` • sheet: ${lastSheetName}` : "") +
        (lastUpdatedAt ? ` • updated: ${fmtUpdatedAt(lastUpdatedAt)}` : "");

      setLoadStatus(meta);
      setDebugStatus("");
      setIngredientCopyBuffer([]); // reset copy buffer
    }

    /**********************
     * Order parsing (robust)
     **********************/
    function parseOrder(text) {
      const lines = text
        .split(/\r?\n/)
        .map(x => x.trim())
        .filter(Boolean);

      const items = [];
      let pendingName = null;

      for (const line of lines) {
        // 0) Warehouse style line: "3 × (1-1-1) Pumpkin"
        const wh = parseWarehouseLine(line);
        if (wh) {
          items.push({ name: wh.name, qty: wh.qty, raw: wh.raw, source: "warehouse", whCode: wh.code });
          pendingName = null;
          continue;
        }

        let l = line
          .replace(/\t+/g, " ")
          .replace(/\u00D7/g, "x")                      // × → x
          .replace(/\u2022|\u2023|\u25E6|\u2043/g, " ") // bullets
          .replace(/\u2013|\u2014/g, "-")               // – — → -
          .replace(/\s+/g, " ")
          .trim();

        const qtyOnly =
          l.match(/^x\s*(\d+)\s*$/i) ||
          l.match(/^qty\s*[:=\-]?\s*(\d+)\s*$/i) ||
          l.match(/^quantity\s*[:=\-]?\s*(\d+)\s*$/i);

        if (qtyOnly && pendingName) {
          items.push({ name: pendingName, qty: Number(qtyOnly[1]), raw: pendingName, source: "plain" });
          pendingName = null;
          continue;
        }

        // qty-first (includes 2) and (2))
        let m =
          l.match(/^\(\s*(\d+)\s*\)\s*(.+)$/i) ||           // (2) Maple
          l.match(/^(\d+)\)\s*(.+)$/i) ||                   // 2) Maple
          l.match(/^(\d+)\s*[:=\-]\s*(.+)$/i) ||            // 2 - Maple
          l.match(/^(\d+)\s*(?:x\s*)?(.+?)\s*$/i);          // 2 Maple / 2 x Maple

        if (m && m[2] && !/^\d+$/.test(m[2].trim())) {
          const qty = Number(m[1]);
          const name = (m[2] ?? "").trim();
          if (qty && name) {
            items.push({ name, qty, raw: line, source: "plain" });
            pendingName = null;
            continue;
          }
        }

        // inline x (qty-first or qty-last)
        m =
          l.match(/^(\d+)\s*x\s*(.+)$/i) ||
          l.match(/^(.+?)\s*x\s*(\d+)$/i) ||
          l.match(/^(.+?)\s*x(\d+)$/i) ||
          l.match(/^(\d+)\s*x(.+)$/i);

        if (m) {
          let qty = null, name = null;
          if (m[1] && /^\d+$/.test(m[1])) { qty = Number(m[1]); name = m[2]; }
          else { name = m[1]; qty = Number(m[2]); }
          if (name && qty) {
            items.push({ name: name.trim(), qty, raw: line, source: "plain" });
            pendingName = null;
            continue;
          }
        }

        // qty-last punct
        m = l.match(/^(.+?)\s*[:=\-,]\s*(\d+)\s*$/);
        if (m) {
          const name = (m[1] ?? "").trim();
          const qty = Number(m[2]);
          if (name && qty) {
            items.push({ name, qty, raw: line, source: "plain" });
            pendingName = null;
            continue;
          }
        }

        // qty-last plain
        m = l.match(/^(.+?)\s+(\d+)\s*$/);
        if (m) {
          const name = (m[1] ?? "").trim();
          const qty = Number(m[2]);
          if (name && qty) {
            items.push({ name, qty, raw: line, source: "plain" });
            pendingName = null;
            continue;
          }
        }

        // qty in parens last
        m = l.match(/^(.+?)\s*\(\s*(\d+)\s*\)\s*$/);
        if (m) {
          const name = (m[1] ?? "").trim();
          const qty = Number(m[2]);
          if (name && qty) {
            items.push({ name, qty, raw: line, source: "plain" });
            pendingName = null;
            continue;
          }
        }

        // bare number line
        if (/^\d+$/.test(l) && pendingName) {
          items.push({ name: pendingName, qty: Number(l), raw: pendingName, source: "plain" });
          pendingName = null;
          continue;
        }

        if (pendingName) items.push({ name: pendingName, qty: 1, raw: pendingName, source: "plain" });
        pendingName = l;
      }

      if (pendingName) items.push({ name: pendingName, qty: 1, raw: pendingName, source: "plain" });

      return items;
    }

    /**********************
     * Order mapper (exact-first; fuzzy last)
     **********************/
    function mapOrder() {
      const includeInactive = false;
      const input = document.getElementById("orderInput").value;
      const items = parseOrder(input);

      const candidates = flavors
        .filter(f => !isExcludedNonFlavor(f))
        .filter(f => includeInactive || f.status.toLowerCase() === "active");

      const out = [];
      const notes = [];

      let totalQty = 0;

      for (const it of items) {
        totalQty += Number(it.qty) || 0;

        const rawLine = it.raw ?? it.name ?? "";
        let text = it.name;

        // If warehouse-style, clean name
        if (it.source === "warehouse") text = cleanWarehouseItemName(text);

        // ---- Cookies & Cream special rule ----
        const nText = norm(text);
        const cText = collapse(text);
        const isCookiesCream =
          nText === "cookies and cream" ||
          cText === "cookiescream" ||
          cText === "cookiesandcream";

        if (isCookiesCream) {
          if (isCookiesCoffeeIntent(rawLine)) {
            // MUST match spreadsheet’s exact name:
            // "Cookies & Cream Protein Coffee"
            const canonical = resolveCanonicalFlavorName("Cookies & Cream Protein Coffee");
            out.push(`${it.qty} x ${canonical}`);
            notes.push(`"${rawLine}" → "${canonical}" (explicit PC/Protein Coffee)`);
          } else {
            const canonical = resolveCanonicalFlavorName("Cookies and Cream");
            out.push(`${it.qty} x ${canonical}`);
            notes.push(`"${rawLine}" → "${canonical}" (default oatmeal)`);
          }
          continue;
        }

        // Customer aliases (only for human-typed inputs)
        if (it.source !== "warehouse") {
          text = applyCustomerAlias(text);
        }

        // 1) Exact flavor_name
        const exactFlavor = exactFlavorLookup.get(norm(text)) || collapsedFlavorLookup.get(collapse(text));
        if (exactFlavor) {
          out.push(`${it.qty} x ${exactFlavor}`);
          if (norm(it.name) !== norm(exactFlavor)) notes.push(`"${rawLine}" → "${exactFlavor}" (exact flavor_name)`);
          continue;
        }

        // 2) Exact warehouse_code (the spreadsheet mapping you care about)
        const exactWh = exactWarehouseLookup.get(norm(text)) || collapsedWarehouseLookup.get(collapse(text));
        if (exactWh) {
          out.push(`${it.qty} x ${exactWh}`);
          notes.push(`"${rawLine}" → "${exactWh}" (exact warehouse_code)`);
          continue;
        }

        // 3) Fuzzy flavor_name (later)
        const bestFlavor = bestFuzzyMatch(text, candidates.map(f => f.flavor_name));
        if (bestFlavor && bestFlavor.score >= 0.62) {
          out.push(`${it.qty} x ${bestFlavor.value}`);
          notes.push(`"${rawLine}" → "${bestFlavor.value}" (fuzzy flavor ${bestFlavor.score.toFixed(2)})`);
          continue;
        }

        // 4) Fuzzy warehouse_code (last resort)
        const bestWarehouse = bestFuzzyMatchObj(text, candidates, f => f.warehouse_code);
        if (bestWarehouse && bestWarehouse.score >= 0.62) {
          out.push(`${it.qty} x ${bestWarehouse.obj.flavor_name}`);
          notes.push(`"${rawLine}" → "${bestWarehouse.obj.flavor_name}" (fuzzy warehouse_code "${bestWarehouse.value}" ${bestWarehouse.score.toFixed(2)})`);
          continue;
        }

        notes.push(`No confident match for: "${rawLine}" (flavor ${(bestFlavor?.score ?? 0).toFixed(2)}, warehouse ${(bestWarehouse?.score ?? 0).toFixed(2)})`);
        out.push(`${it.qty} x ${it.name}  [UNMATCHED]`);
      }

      // Put total at top for agent speed
      const header = `TOTAL ITEMS: ${totalQty}`;
      document.getElementById("orderOutput").value = [header, ...out].join("\n");

      document.getElementById("orderNotes").innerHTML = notes.length
        ? `<div><strong>Match notes</strong></div><div class="muted">${notes.map(escapeHtml).join("<br/>")}</div>`
        : `<span class="muted">All items matched cleanly.</span>`;
    }

    /**********************
     * Label lookup
     **********************/
    function lookupLabel() {
      const q = document.getElementById("labelFlavor").value;
      if (!q.trim()) return;

      const active = flavors.filter(f => f.status.toLowerCase() === "active");
      const best = bestFuzzyMatch(q, active.map(f => f.flavor_name));
      const container = document.getElementById("labelResult");

      if (!best || best.score < 0.62) {
        container.innerHTML = `<div class="muted">No confident match for “${escapeHtml(q)}”.</div>`;
        return;
      }

      const f = active.find(x => x.flavor_name === best.value);
      const nut = f.nutrition;

      const nutRows = nutritionCols.map(k => {
        const v = nut[k];
        return `<tr><td>${escapeHtml(k)}</td><td class="right">${v ?? ""}</td></tr>`;
      }).join("");

      container.innerHTML = `
        <div><strong>${escapeHtml(f.flavor_name)}</strong> <span class="pill">${escapeHtml(f.status)}</span></div>
        <div class="muted">Match score: ${best.score.toFixed(2)}</div>
        <div class="grid" style="margin-top:8px;">
          <div class="card" style="padding:10px;">
            <div class="muted">Nutrition</div>
            <table>${nutRows}</table>
          </div>
          <div class="card" style="padding:10px;">
            <div class="muted">Ingredients</div>
            <div>${f.ingredients.length ? escapeHtml(f.ingredients.join(", ")) : "<span class='muted'>(none listed)</span>"}</div>
          </div>
        </div>
      `;
    }

    /**********************
     * Ingredient lookup (WITH ingredient)
     **********************/
    function searchIngredient() {
      const qRaw = document.getElementById("ingredientQuery").value;
      const qNorm = norm(qRaw);
      const includeInactive = document.getElementById("includeInactiveIng").checked;

      if (!qNorm) {
        document.getElementById("ingredientResult").innerHTML = `<div class="muted">Type an ingredient to search.</div>`;
        setIngredientCopyBuffer([]);
        return;
      }

      const pool = flavors
        .filter(f => !isExcludedNonFlavor(f))
        .filter(f => includeInactive || f.status.toLowerCase() === "active");

      const hits = [];
      const matchedVariants = new Map();

      for (const f of pool) {
        let best = 0;
        let bestVariant = null;

        for (const ing of f.ingredients) {
          const sc = ingredientScore(qRaw, ing);
          if (sc > best) { best = sc; bestVariant = ing; }
        }

        if (best >= 0.58) {
          hits.push({ flavor: f.flavor_name, status: f.status, score: best, variant: bestVariant });
          matchedVariants.set(bestVariant, (matchedVariants.get(bestVariant) || 0) + 1);
        }
      }

      hits.sort((a,b) => b.score - a.score);

      const variants = [...matchedVariants.entries()]
        .sort((a,b) => b[1]-a[1])
        .slice(0, 20)
        .map(([v,c]) => `<div class="pill">${escapeHtml(v)} • ${c}</div>`)
        .join(" ");

      const list = hits.slice(0, 120).map(h =>
        `<div>${escapeHtml(h.flavor)} <span class="${h.status.toLowerCase()==="active"?"statusActive":"statusInactive"}">(${escapeHtml(h.status)})</span>
        <span class="muted">— ${escapeHtml(h.variant)} — score ${h.score.toFixed(2)}</span></div>`
      ).join("");

      document.getElementById("ingredientResult").innerHTML = `
        <div><strong>${hits.length}</strong> flavors matched “${escapeHtml(qRaw)}”.</div>
        ${variants ? `<div class="muted" style="margin-top:6px;">Common matched variants:</div><div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">${variants}</div>` : ""}
        <div style="margin-top:10px;">${list || "<div class='muted'>(no matches)</div>"}</div>
      `;

      // copyable list (one per line)
      setIngredientCopyBuffer(hits.map(h => h.flavor));
    }

    /**********************
     * Ingredient lookup (WITHOUT ingredient)
     **********************/
    function listFlavorsWithoutIngredient() {
      const qRaw = document.getElementById("ingredientQuery").value;
      const qNorm = norm(qRaw);
      const includeInactive = document.getElementById("includeInactiveIng").checked;

      if (!qNorm) {
        document.getElementById("ingredientResult").innerHTML = `<div class="muted">Type an ingredient to check for missing.</div>`;
        setIngredientCopyBuffer([]);
        return;
      }

      const pool = flavors
        .filter(f => !isExcludedNonFlavor(f))
        .filter(f => includeInactive || f.status.toLowerCase() === "active");

      // consider it "present" if any ingredient cell matches above threshold
      const missing = [];
      for (const f of pool) {
        let best = 0;
        for (const ing of f.ingredients) {
          const sc = ingredientScore(qRaw, ing);
          if (sc > best) best = sc;
        }
        if (best < 0.58) missing.push(f);
      }

      missing.sort((a,b) => a.flavor_name.localeCompare(b.flavor_name));

      const list = missing.slice(0, 200).map(f =>
        `<div>${escapeHtml(f.flavor_name)} <span class="muted">— ${escapeHtml(f.product || "")} — ${escapeHtml(f.vegan || "unknown")}</span></div>`
      ).join("");

      document.getElementById("ingredientResult").innerHTML = `
        <div><strong>${missing.length}</strong> flavors <strong>without</strong> “${escapeHtml(qRaw)}”.</div>
        <div class="muted" style="margin-top:6px;">(Shakers/scoops excluded.)</div>
        <div style="margin-top:10px;">${list || "<div class='muted'>(none)</div>"}</div>
      `;

      setIngredientCopyBuffer(missing.map(f => f.flavor_name));
    }

    /**********************
     * Nutrition extremes
     **********************/
    function computeExtremes() {
      const includeInactive = document.getElementById("includeInactiveNut").checked;
      const macro = document.getElementById("macroSelect").value;
      const filterValue = document.getElementById("productFilter").value;
      const veganValue = document.getElementById("veganFilter").value;

      let pool = flavors.slice();
      pool = pool.filter(f => !isExcludedNonFlavor(f));
      pool = pool.filter(f => includeInactive || f.status.toLowerCase() === "active");
      pool = pool.filter(f => productPassesFilter(f, filterValue));
      pool = pool.filter(f => veganPassesFilter(f, veganValue));

      if (!macro) {
        document.getElementById("extremes").innerHTML = `<div class="muted">Select a macro/nutrient.</div>`;
        return;
      }

      const vals = pool
        .map(f => ({ name: f.flavor_name, v: f.nutrition[macro], status: f.status }))
        .filter(x => typeof x.v === "number");

      if (!vals.length) {
        document.getElementById("extremes").innerHTML =
          `<div class="muted">No numeric values found for <strong>${escapeHtml(macro)}</strong> in the filtered set.</div>`;
        return;
      }

      vals.sort((a,b) => a.v - b.v);
      const least = vals.slice(0, 10);
      const most = vals.slice(-10).reverse();

      const fmt = (arr) => arr.map(x =>
        `<div>${escapeHtml(x.name)} <span class="muted">(${x.v})</span></div>`
      ).join("");

      document.getElementById("extremes").innerHTML = `
        <div class="card" style="padding:10px;">
          <div>
            <strong>${escapeHtml(macro)}</strong>
            <span class="pill">top/bottom 10</span>
          </div>
          <div class="muted" style="margin-top:4px;">
            Filter: ${escapeHtml(filterValue)} • Vegan: ${escapeHtml(veganValue)} • ${includeInactive ? "including inactive" : "active only"} • excluding shakers/scoops
          </div>
          <div class="grid" style="margin-top:10px;">
            <div><div class="muted">Least</div>${fmt(least)}</div>
            <div><div class="muted">Most</div>${fmt(most)}</div>
          </div>
        </div>
      `;
    }

    /**********************
     * Table rendering (sortable)
     **********************/
    function renderTable() {
      const q = norm(document.getElementById("tableSearch").value);

      const productFilter = document.getElementById("tableProductFilter").value;
      const veganFilter = document.getElementById("tableVeganFilter").value;
      const includeInactive = document.getElementById("tableIncludeInactive").checked;

      let view = flavors.slice();

      // Exclude non-flavors always
      view = view.filter(f => !isExcludedNonFlavor(f));

      // Only show flavors with at least one nutrition value
      view = view.filter(f => nutritionCols.some(k => typeof f.nutrition[k] === "number"));

      // Active/inactive
      view = view.filter(f => includeInactive || f.status.toLowerCase() === "active");

      // Product filter
      view = view.filter(f => productPassesFilter(f, productFilter));

      // Vegan filter
      view = view.filter(f => veganPassesFilter(f, veganFilter));

      // Search
      if (q) {
        view = view.filter(f =>
          f.flavor_name_norm.includes(q) ||
          norm(f.product).includes(q)
        );
      }

      const { key, dir } = tableSort;
      view.sort((a,b) => {
        const mul = dir === "asc" ? 1 : -1;
        const av = key.startsWith("nutrition.") ? a.nutrition[key.split(".")[1]] : a[key];
        const bv = key.startsWith("nutrition.") ? b.nutrition[key.split(".")[1]] : b[key];

        if (av == null && bv == null) return 0;
        if (av == null) return 1 * mul;
        if (bv == null) return -1 * mul;

        if (typeof av === "number" && typeof bv === "number") return (av - bv) * mul;
        return av.toString().localeCompare(bv.toString()) * mul;
      });

      const cols = [
        { key: "status", label: "Status" },
        { key: "flavor_name", label: "Flavor" },
        { key: "product", label: "Product" },
        { key: "vegan", label: "Vegan" },
        ...nutritionCols.map(c => ({ key: `nutrition.${c}`, label: c })),
      ];

      const th = cols.map(c => {
        const is = tableSort.key === c.key;
        const arrow = is ? (tableSort.dir === "asc" ? " ▲" : " ▼") : "";
        return `<th data-key="${escapeHtml(c.key)}">${escapeHtml(c.label)}${arrow}</th>`;
      }).join("");

      const tbody = view.slice(0, 700).map(f => {
        const statusClass = f.status.toLowerCase()==="active" ? "statusActive" : "statusInactive";
        const tds = cols.map(c => {
          if (c.key === "status") {
            return `<td><span class="${statusClass}">${escapeHtml(f.status)}</span></td>`;
          }
          if (c.key.startsWith("nutrition.")) {
            const k = c.key.split(".")[1];
            return `<td class="right mono">${f.nutrition[k] ?? ""}</td>`;
          }
          return `<td>${escapeHtml(f[c.key] ?? "")}</td>`;
        }).join("");
        return `<tr>${tds}</tr>`;
      }).join("");

      const table = document.getElementById("flavorTable");
      table.innerHTML = `<thead><tr>${th}</tr></thead><tbody>${tbody}</tbody>`;

      table.querySelectorAll("th").forEach(el => {
        el.addEventListener("click", () => {
          const k = el.getAttribute("data-key");
          if (tableSort.key === k) tableSort.dir = tableSort.dir === "asc" ? "desc" : "asc";
          else { tableSort.key = k; tableSort.dir = "asc"; }
          renderTable();
        });
      });
    }

    /**********************
     * Google Sheets loader (with debug)
     **********************/
    async function loadFromGoogleSheet() {
      setLoadStatus("Loading from Google Sheets…");
      setDebugStatus("");
      setEnabled(false);

      try {
        // cache-bust to avoid “stuck” deployments or caching issues
        const url = `${SHEET_API_URL}${SHEET_API_URL.includes("?") ? "&" : "?"}t=${Date.now()}`;

        const res = await fetch(url, {
          method: "GET",
          cache: "no-store",
          redirect: "follow"
        });

        const text = await res.text();

        if (!res.ok) {
          setDebugStatus(`HTTP ${res.status} ${res.statusText}. First 200 chars: ${text.slice(0,200)}`);
          throw new Error(`HTTP ${res.status}`);
        }

        // If you accidentally got the Google login HTML, this will catch it
        if (text.trim().startsWith("<")) {
          setDebugStatus(`Response looks like HTML (not JSON). First 200 chars: ${text.slice(0,200)}`);
          throw new Error("Response was HTML (usually auth/login or wrong deployment)");
        }

        let data;
        try { data = JSON.parse(text); }
        catch (e) {
          setDebugStatus(`JSON parse failed. First 200 chars: ${text.slice(0,200)}`);
          throw new Error("Response was not valid JSON");
        }

        if (!data || data.ok !== true || !Array.isArray(data.rows)) {
          setDebugStatus(`Unexpected JSON shape. Keys: ${Object.keys(data || {}).join(", ")}`);
          throw new Error("Unexpected JSON (expected { ok:true, rows:[...] })");
        }

        lastUpdatedAt = data.updated_at || null;
        lastSheetName = data.sheet || null;

        buildModel(data.rows);
      } catch (err) {
        console.error(err);
        setLoadStatus(`Failed to load from Google Sheets: ${err.message}`);
      }
    }

    /**********************
     * Wire up UI
     **********************/
    document.getElementById("refreshData").addEventListener("click", loadFromGoogleSheet);

    document.getElementById("mapOrder").addEventListener("click", mapOrder);
    document.getElementById("lookupLabel").addEventListener("click", lookupLabel);

    document.getElementById("searchIngredient").addEventListener("click", searchIngredient);
    document.getElementById("listWithoutIngredient").addEventListener("click", listFlavorsWithoutIngredient);
    document.getElementById("copyIngredientResults").addEventListener("click", copyIngredientResults);

    document.getElementById("ingredientQuery").addEventListener("input", () => setIngredientCopyBuffer([]));

    document.getElementById("calcExtremes").addEventListener("click", computeExtremes);
    document.getElementById("macroSelect").addEventListener("change", computeExtremes);
    document.getElementById("productFilter").addEventListener("change", computeExtremes);
    document.getElementById("veganFilter").addEventListener("change", computeExtremes);
    document.getElementById("includeInactiveNut").addEventListener("change", computeExtremes);

    document.getElementById("tableSearch").addEventListener("input", renderTable);
    document.getElementById("tableProductFilter").addEventListener("change", renderTable);
    document.getElementById("tableVeganFilter").addEventListener("change", renderTable);
    document.getElementById("tableIncludeInactive").addEventListener("change", renderTable);

    document.getElementById("labelFlavor").addEventListener("keydown", (e) => { if (e.key === "Enter") lookupLabel(); });
    document.getElementById("ingredientQuery").addEventListener("keydown", (e) => {
      if (e.key === "Enter") searchIngredient();
    });

    // Initial state
    document.getElementById("refreshData").disabled = false;
    setEnabled(false);

    // Auto-load immediately
    loadFromGoogleSheet();

    // Auto-refresh every N minutes (only when tab visible)
    setInterval(() => {
      if (document.visibilityState === "visible") loadFromGoogleSheet();
    }, AUTO_REFRESH_MINUTES * 60 * 1000);
  </script>
</body>
</html>
